// depreciated methods of cut overlap correction:
				
								boolean anycuts = false; // will be used to keep track of whether or not any nodes were actually drawn
				// if nothing exists on this layer with the 'cut' property, this image will simply be discarded and not saved.
				
				i =0;
				while(i<nodecount){
					// this segment mirrors the buffer and draw code from before, except now only
					// outlines are to be drawn, and only of cut nodes
					double buffersize = 1.0/(double)(pixconv); // ex 20 -> 1 = 2 pix
					MapNode inode = allnodes[i];
					int iz = inode.getFillZ();
					if(iz==zz && inode.getCut()){ // ascertain it's a cut node & on the current z-layer
						anycuts=true;
						int ix = center_x + (int)(pixconv*inode.getFillX());
						int iy = center_y + (int)(pixconv*inode.getFillY());
	
						if(inode.isRect()){// && inode.getRectStartNeighbor()!=-1){
							double angle = 180;
							if(inode.getRectStartNeighbor()!=-1){
								int snode_num = inode.getRectStartNeighbor();
								MapNode snode = inode.getNeighbor(snode_num);
								angle = inode.getNeighborAngle(snode_num);
							}
							double rlen = inode.getRectLen()+buffersize*2;
							double rwid = inode.getRectWid()+buffersize*2;
	
							int irwid = (int)(rwid*pixconv);
							int irlen = (int)(rlen*pixconv);
							drawRectAngle(raster,ix,iy,irlen,irwid,black,Math.toRadians(angle),0,irwid/2,
									nodeidraster,i);
							ix += (int)(pixconv*Math.cos(angle)*(buffersize*2));
							iy += (int)(pixconv*Math.sin(angle)*(buffersize*2));
							drawRectAngle(raster,ix,iy,irlen-4,irwid-4,white,Math.toRadians(angle),(int)((-buffersize/2)*pixconv),
									(irwid-2)/2,nodeidraster,i);
						}else if(inode.isCorner()){
							double startangle = 180;
							if(inode.getRectStartNeighbor()!=-1){
								int snode_num = inode.getRectStartNeighbor();
								MapNode snode = inode.getNeighbor(snode_num);
								startangle = inode.getNeighborAngle(snode_num);
							}
							double rbase = inode.getCornerBase();
							double rhei = inode.getCornerHeight();
							int irbase = (int)(rbase*pixconv);
							int irhei = (int)(rhei*pixconv);
							drawCorner(raster,ix,iy,irbase,irhei,black,Math.toRadians(startangle),Math.toRadians(inode.getCornerAngle()),
									inode.getCornerCurveweight(),(int)(buffersize*pixconv),irbase/2,nodeidraster,i);
							ix += (int)(pixconv*Math.cos(startangle)*(buffersize*2));
							iy += (int)(pixconv*Math.sin(startangle)*(buffersize*2));
							drawCorner(raster,ix,iy,irbase-4,irhei-4,white,Math.toRadians(startangle),Math.toRadians(inode.getCornerAngle()),
									inode.getCornerCurveweight(),(int)((buffersize/2)*pixconv),(irbase-2)/2,nodeidraster,i);
						}else if(inode.isCircle()){
							if(inode.getCircleInner()!=-1){
								drawDisk(raster,ix,iy,(int)(pixconv*(inode.getCircleRadius()+buffersize)),
										(int)(pixconv*(inode.getCircleRadius()+buffersize))-2,
										black,nodeidraster,i);
								drawDisk(raster,ix,iy,(int)(pixconv*(inode.getCircleInner()-buffersize)),
										(int)(pixconv*(inode.getCircleInner()-buffersize))-2,
										black,nodeidraster,i);
							}else{
								drawDisk(raster,ix,iy,(int)(pixconv*(inode.getCircleRadius()+buffersize)),
										(int)(pixconv*(inode.getCircleRadius()+buffersize))-2,black,nodeidraster,i);
							}
						}else if(inode.isPolygon()){
							double angle = 180;
							if(inode.getRectStartNeighbor()!=-1){
								angle = inode.getNeighborAngle(inode.getRectStartNeighbor());
							}
							double[][] polypoints = inode.getPolygonBPoints(pixconv,buffersize);
							int[] polyx = new int[inode.getPolygonVs()];
							int[] polyy = new int[inode.getPolygonVs()];
							int pi =0;
							while(pi<inode.getPolygonVs()){
								polyx[pi]=(int)(polypoints[pi][0]*pixconv);
								polyy[pi]=(int)(polypoints[pi][1]*pixconv);
								pi++;
							}
							int[] polyc = inode.getPolygonCtypes();
							double[] polycw = inode.getPolygonCurveWeights();
							drawPoly(raster, ix,iy, polyx,polyy, polyc, polycw, inode.getPolygonVs(), 
									black, Math.toRadians(angle), (int)inode.getPolygonCrotX()*pixconv, 
									(int)inode.getPolygonCrotY()*pixconv, false, nodeidraster,i);
							
							
						}
					}
					i++;
				}
				// SECOND PASS
				// If cut_overlap is false, then this sequence attempts to remove all overlapping edges that were just drawn;
				// an overlapping edge is one that exists inside of another shape's body. 
				if(!cut_overlap){
					i =0;
					while(i<nodecount){
						//System.out.println("RENDERING NODE " + i);
						MapNode inode = allnodes[i];
						int iz = inode.getFillZ();
						if(iz==zz && inode.getCut()){
							int ix = center_x + (int)(pixconv*inode.getFillX());
							int iy = center_y + (int)(pixconv*inode.getFillY());
							if(inode.isRect()){// && inode.getRectStartNeighbor()!=-1){
								double angle = 180;
								if(inode.getRectStartNeighbor()!=-1){
									int snode_num = inode.getRectStartNeighbor();
									MapNode snode = inode.getNeighbor(snode_num);
									angle = inode.getNeighborAngle(snode_num);
								}
								double rlen = inode.getRectLen();
								double rwid = inode.getRectWid();
								
								int irwid = (int)(rwid*pixconv);
								int irlen = (int)(rlen*pixconv);
								drawRectAngle(raster,ix,iy,irlen,irwid,white,Math.toRadians(angle),0,irwid/2,nodeidraster,i);
							}else if(inode.isCorner()){
								double startangle = 180;
								if(inode.getRectStartNeighbor()!=-1){
									int snode_num = inode.getRectStartNeighbor();
									MapNode snode = inode.getNeighbor(snode_num);
									startangle = inode.getNeighborAngle(snode_num);
								}
								double rbase = inode.getCornerBase();
								double rhei = inode.getCornerHeight();
								int irbase = (int)(rbase*pixconv);
								int irhei = (int)(rhei*pixconv);
								drawCorner(raster,ix,iy,irbase,irhei,white,Math.toRadians(startangle),Math.toRadians(inode.getCornerAngle()),
										inode.getCornerCurveweight(),0,irbase/2,nodeidraster,i);
							}else if(inode.isCircle()){
								if(inode.getCircleInner()!=-1){
									drawDisk(raster,ix,iy,(int)(pixconv*inode.getCircleRadius()),(int)(pixconv*inode.getCircleInner()),
											white,nodeidraster,i);
								}else{
									drawCircle(raster,ix,iy,(int)(pixconv*inode.getCircleRadius()),white,nodeidraster,i);
								}
							}else if(inode.isPolygon()){
								double angle = 180;
								if(inode.getRectStartNeighbor()!=-1){
									angle = inode.getNeighborAngle(inode.getRectStartNeighbor());
								}
								int[] polyx = new int[inode.getPolygonVs()];
								int[] polyy = new int[inode.getPolygonVs()];
								int pi =0;
								while(pi<inode.getPolygonVs()){
									polyx[pi]=(int)(inode.getPolygonX(pi)*pixconv);
									polyy[pi]=(int)(inode.getPolygonY(pi)*pixconv);
									pi++;
								}
								int[] polyc = inode.getPolygonCtypes();
								double[] polycw = inode.getPolygonCurveWeights();
								drawPoly(raster, ix,iy, polyx,polyy, polyc, polycw, inode.getPolygonVs(), 
										white, Math.toRadians(angle), (int)inode.getPolygonCrotX()*pixconv, 
										(int)inode.getPolygonCrotY()*pixconv, inode.getPolygonFilled(),nodeidraster,i);
							}
						}
						i++;
					}
				}
				
				/*i =0;
				while(i<nodecount){
					//System.out.println("RENDERING NODE " + i);
					MapNode inode = allnodes[i];
					int iz = inode.getFillZ();
					if(iz==zz && inode.getCut()){
						anycuts=true;
						int ix = center_x + (int)(pixconv*inode.getFillX());
						int iy = center_y + (int)(pixconv*inode.getFillY());
						if(inode.isRect() && inode.getRectStartNeighbor()!=-1){
							int snode_num = inode.getRectStartNeighbor();
							MapNode snode = inode.getNeighbor(snode_num);
							double angle = inode.getNeighborAngle(snode_num);
							double rlen = inode.getRectLen();
							double rwid = inode.getRectWid();
							
							
							int irwid = (int)(rwid*pixconv);
							int irlen = (int)(rlen*pixconv);
							drawRectAngleOutline(raster,ix,iy,irlen,irwid,black,Math.toRadians(angle),0,0);//irwid/2);
						}else if(inode.isCircle()){
							if(inode.getCircleInner()!=-1){
								drawDisk(raster,ix,iy,(int)(pixconv*inode.getCircleRadius()),(int)(pixconv*inode.getCircleRadius())-2,
										black);
								drawDisk(raster,ix,iy,(int)(pixconv*inode.getCircleInner()),(int)(pixconv*inode.getCircleInner())-2,
										black);
							}else{
								drawDisk(raster,ix,iy,(int)(pixconv*inode.getCircleRadius()),(int)(pixconv*inode.getCircleRadius())-2,black);
							}
						}else if(inode.isPolygon()){
							double angle = 0;
							if(inode.getRectStartNeighbor()!=-1){
								angle = inode.getNeighborAngle(inode.getRectStartNeighbor());
							}
							int[] polyx = new int[inode.getPolygonVs()];
							int[] polyy = new int[inode.getPolygonVs()];
							int pi =0;
							while(pi<inode.getPolygonVs()){
								polyx[pi]=(int)(inode.getPolygonX(pi)*pixconv);
								polyy[pi]=(int)(inode.getPolygonY(pi)*pixconv);
								pi++;
							}
							int[] polyc = inode.getPolygonCtypes();
							drawPoly(raster, ix,iy, polyx,polyy, polyc, inode.getPolygonVs(), 
									black, Math.toRadians(angle), (int)inode.getPolygonCrotX()*pixconv, 
									(int)inode.getPolygonCrotY()*pixconv, false);
						}
					}
					i++;
				}
				
				
				if(!cut_overlap){
					int[][] overlap = new int[total_x][total_y];
					int h=0;
					while(h<total_x){
						int j=0;
						while(j<total_y){
							overlap[h][j]=0;
							j++;
						}
						h++;
					}
					BufferedImage tempimage = new BufferedImage(total_x, total_y, BufferedImage.TYPE_INT_RGB);
					WritableRaster tempraster = tempimage.getRaster();
					
					i =0;
					while(i<nodecount){
						drawRectangle(tempraster,0,0,tempraster.getWidth(),tempraster.getHeight(),black);
						//System.out.println("RENDERING NODE " + i);
						MapNode inode = allnodes[i];
						int iz = inode.getFillZ();
						if(iz==zz){
							int ix = center_x + (int)(pixconv*inode.getFillX());
							int iy = center_y + (int)(pixconv*inode.getFillY());
							if(inode.isRect() && inode.getRectStartNeighbor()!=-1){
								int snode_num = inode.getRectStartNeighbor();
								MapNode snode = inode.getNeighbor(snode_num);
								double angle = inode.getNeighborAngle(snode_num);
								double rlen = inode.getRectLen();
								double rwid = inode.getRectWid();
								
								
								int irwid = (int)(rwid*pixconv);
								int irlen = (int)(rlen*pixconv);
								// enlargement used for overlap system
								//irwid+=2;
								//irlen+=2;
								// pre overlap:
								//ix+=(int)(1*Math.cos(Math.toRadians(angle)));
								//iy+=(int)(1*Math.sin(Math.toRadians(angle)));
								// overlap:
								//ix-=(int)(1*Math.cos(Math.toRadians(angle)));
								//iy-=(int)(1*Math.sin(Math.toRadians(angle)));
								drawRectAngle(tempraster,ix,iy,
										irlen,irwid,white,Math.toRadians(angle),0,(irwid)/2);
							}else if(inode.isCircle()){
								if(inode.getCircleInner()!=-1){
									drawDisk(tempraster,ix,iy,(int)(pixconv*inode.getCircleRadius())-2,(int)(pixconv*inode.getCircleInner())+2,
											white);
								}else{
									drawCircle(tempraster,ix,iy,(int)(pixconv*inode.getCircleRadius())-2,white);
								}
							}else if(inode.isPolygon()){
								double angle = 0;
								if(inode.getRectStartNeighbor()!=-1){
									angle = inode.getNeighborAngle(inode.getRectStartNeighbor());
								}
								// pre:overlap, would just draw a smaller polygon
								System.out.println(" GRAB CUT OVERLAP ");
								double[][] polypoints = inode.getPolygonBPoints(pixconv,-1);
								int[] polyx = new int[inode.getPolygonVs()];
								int[] polyy = new int[inode.getPolygonVs()];
								int pi =0;
								while(pi<inode.getPolygonVs()){
									polyx[pi]=(int)(polypoints[pi][0]*pixconv);
									polyy[pi]=(int)(polypoints[pi][1]*pixconv);
									//polyx[pi]=(int)(inode.get_polygon_x(pi)*pixconv);
									//polyy[pi]=(int)(inode.get_polygon_y(pi)*pixconv);
									pi++;
								}
								int[] polyc = inode.getPolygonCtypes();
								drawPoly(tempraster, ix,iy, polyx,polyy, polyc, inode.getPolygonVs(), 
										white, Math.toRadians(angle), (int)inode.getPolygonCrotX()*pixconv, 
										(int)inode.getPolygonCrotY()*pixconv, true);
							}
							// now add the tempraster to the overlap array
							h=0;
							while(h<total_x){
								int j=0;
								while(j<total_y){
									int[] col = new int[3];
									col = tempraster.getPixel(h,j, col);
									if(col[0]>=128){
										if(overlap[h][j]==0){
											overlap[h][j]=i+10;
										}else{
											overlap[h][j]=-2;
										}
									}
									j++;
								}
								h++;
							}
						}
						i++;
					}
					// now transfer the overlap array onto the regular raster
					//int h=0;
					//while(h<total_x){
					//	int j=0;
					//	while(j<total_y){
					//		if(overlap[h][j]>1){
					//			raster.setPixel(h,j,white);
					//		}
					//		j++;
					//	}
					//	h++;
					//}/
					// new overlap detection:
					// 1. for each black pixel, see if it is surrounded on both sides by existing shapes 
					h =0;
					while(h<total_x){
						int j=0;
						while(j<total_y){
							int[] col = new int[3];
							col = raster.getPixel(h,j, col);
							boolean set= false;
							if(col[0]<128){
								int dirs = 0;
								int wdirs = 0; // directions of emptiness
								int cond =overlap[h][j];
								if(h>0){
									if(overlap[h-1][j]==-2){
										dirs++;
										if(cond>0){
											dirs++;
										}
										cond=-2;
									}else if(overlap[h-1][j]>0){
										if(cond!=overlap[h-1][j] && cond!=0){
											dirs++;
										}
										cond=overlap[h-1][j];
									}else if(overlap[h-1][j]==0){
										wdirs++;
									}
								}
								if(h<total_x-1){
									if(overlap[h+1][j]==-2){
										dirs++;
										if(cond>0){
											dirs++;
										}
										cond=-2;
									}else if(overlap[h+1][j]>0){
										if(cond!=overlap[h+1][j] && cond!=0){
											dirs++;
										}
										cond=overlap[h+1][j];
									}else if(overlap[h+1][j]==0){
										wdirs++;
									}
								}
								cond=overlap[h][j];
								if(j>0){
									if(overlap[h][j-1]==-2){
										dirs++;
										if(cond>0){
											dirs++;
										}
										cond=-2;
									}else if(overlap[h][j-1]>0){
										if(cond!=overlap[h][j-1] && cond!=0){
											dirs++;
										}
										cond=overlap[h][j-1];
									}else if(overlap[h][j-1]==0){
										wdirs++;
									}
								}
								
								if(j<total_y-1){
									if(overlap[h][j+1]==-2){
										dirs++;
										if(cond>0){
											dirs++;
										}
										cond=-2;
									}else if(overlap[h][j+1]>0){
										if(cond!=overlap[h][j+1] && cond!=0){
											dirs++;
										}
										cond=overlap[h][j+1];
									}else if(overlap[h][j+1]==0){
										wdirs++;
									}
								}
								if((dirs>1 && overlap[h][j]!=-2 && wdirs==0) || (dirs>3 && wdirs==0)){
									raster.setPixel(h,j,white);//new int[]{50*dirs,50*dirs,50*dirs});
									set=true;
								}
							}
							if(!set){
								if(overlap[h][j]==-2){
									//raster.setPixel(h,j,new int[]{255,0,0});
								}else if(overlap[h][j]>0){
									//raster.setPixel(h,j,new int[]{overlap[h][j]*3,overlap[h][j]*5,overlap[h][j]*4});
								}
							}
							j++;
						}
						h++;
					}
				}*/